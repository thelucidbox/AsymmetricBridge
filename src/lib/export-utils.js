const MIME_MARKDOWN = "text/markdown;charset=utf-8";

export async function copyToClipboard(text) {
  await navigator.clipboard.writeText(text);
}

export function downloadFile(content, filename, mime = MIME_MARKDOWN) {
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const anchor = document.createElement("a");
  anchor.href = url;
  anchor.download = filename;
  anchor.click();
  URL.revokeObjectURL(url);
}

function formatDate(iso) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "N/A";
  return d.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
}

function formatPercent(value, digits = 1) {
  return `${(Number(value) || 0).toFixed(digits)}%`;
}

function formatCurrency(value) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    maximumFractionDigits: 0,
  }).format(Number(value) || 0);
}

function conditionLabel(prediction) {
  const condition = prediction.condition || {};
  if (prediction.type === "threshold") {
    const op =
      { gte: ">=", gt: ">", lte: "<=", lt: "<" }[condition.operator] || ">=";
    return `${op} ${condition.threshold}`;
  }
  if (prediction.type === "direction") {
    const dir = condition.direction === "down" ? "Down" : "Up";
    return condition.baselineValue
      ? `${dir} vs ${condition.baselineValue}`
      : dir;
  }
  return `${condition.min} – ${condition.max}`;
}

export function predictionsToMarkdown(predictions, battingAverage) {
  const scored = predictions.filter((p) => p.status === "scored" || p.outcome);
  const active = predictions.filter(
    (p) => p.status === "pending" && !p.outcome,
  );
  const pct = Math.round((battingAverage || 0) * 100);
  const now = new Date().toISOString().slice(0, 10);

  const lines = [
    `# Conviction Ledger`,
    ``,
    `**Batting Average:** ${pct}% (${scored.length} scored / ${predictions.length} total)`,
    `**Exported:** ${now}`,
    ``,
  ];

  if (active.length > 0) {
    lines.push(`## Active Predictions (${active.length})`, ``);
    for (const p of active) {
      lines.push(
        `- **${p.signalName || "Unknown"}** (${p.type}) — ${conditionLabel(p)} by ${formatDate(p.targetDate)}`,
      );
      if (p.notes) lines.push(`  > ${p.notes}`);
    }
    lines.push(``);
  }

  if (scored.length > 0) {
    lines.push(`## Scored Predictions (${scored.length})`, ``);
    lines.push(`| Signal | Type | Condition | Target Date | Outcome |`);
    lines.push(`|--------|------|-----------|-------------|---------|`);
    for (const p of scored) {
      const outcome = (p.outcome || "unknown").toUpperCase();
      lines.push(
        `| ${p.signalName || "Unknown"} | ${p.type} | ${conditionLabel(p)} | ${formatDate(p.targetDate)} | ${outcome} |`,
      );
    }
    lines.push(``);
  }

  return lines.join("\n");
}

export function performanceToMarkdown(
  alignmentScore,
  legBreakdown,
  positions,
  totalValue,
  format,
) {
  const now = new Date().toISOString().slice(0, 10);
  const breakdown = alignmentScore.breakdown || [];

  const lines = [
    `# Thesis Performance Lab Report`,
    ``,
    `**Alignment Score:** ${Math.round(alignmentScore.score || 0)}/100`,
    `**Portfolio Value:** ${formatCurrency(totalValue)}`,
    `**Brokerage Format:** ${format || "Unknown"}`,
    `**Positions:** ${positions.length}`,
    `**Exported:** ${now}`,
    ``,
    `## Allocation by Thesis Leg`,
    ``,
    `| Leg | Actual | Target | Delta | Value |`,
    `|-----|--------|--------|-------|-------|`,
  ];

  for (const row of breakdown) {
    const mapped = legBreakdown.find((l) => l.legName === row.leg);
    const target =
      row.targetPercent !== null ? formatPercent(row.targetPercent) : "N/A";
    const delta = row.delta !== null ? formatPercent(row.delta) : "N/A";
    lines.push(
      `| ${row.leg} | ${formatPercent(row.actualPercent)} | ${target} | ${delta} | ${formatCurrency(row.totalValue)} |`,
    );
  }

  lines.push(``);

  const unaligned = legBreakdown.find((b) => b.legName === "Unaligned");
  if (unaligned?.positions?.length) {
    lines.push(`## Unaligned Positions (${unaligned.positions.length})`, ``);
    lines.push(`| Symbol | Quantity | Market Value |`);
    lines.push(`|--------|----------|-------------|`);
    for (const pos of unaligned.positions) {
      lines.push(
        `| ${pos.symbol} | ${Number(pos.quantity || 0).toFixed(4)} | ${formatCurrency(pos.marketValue)} |`,
      );
    }
    lines.push(``);
  }

  lines.push(
    `---`,
    `*Generated by [Asymmetric Bridge](https://github.com/thelucidbox/AsymmetricBridge)*`,
  );

  return lines.join("\n");
}
